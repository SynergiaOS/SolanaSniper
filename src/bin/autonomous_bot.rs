/*!
üß† SniperBot 2.0 - Autonomous Trading Organism

The Persistent Brain - Hub-and-Spoke Architecture with DragonflyDB

This is the autonomous heart that beats continuously, orchestrating:
- DragonflyDB as the central nervous system
- Pipeline Controller as the processing brain
- Continuous operation without manual intervention
- Graceful shutdown and restart capabilities
*/

use sniper_bot::config::AppConfig;
use sniper_bot::db_connector::{DbClient, DbConfig};
use sniper_bot::pipeline::controller::PipelineController;
use sniper_bot::models::TradingResult;
use clap::{Arg, Command};
use dotenvy::dotenv;
use std::env;
use std::time::Duration;
use tokio::signal;
use tokio::time::interval;
use tracing::{info, error, warn, debug};
use tracing_subscriber::{fmt, EnvFilter};

#[tokio::main]
async fn main() -> TradingResult<()> {
    // === PHASE 1: SYSTEM INITIALIZATION ===
    
    // Load environment variables
    dotenv().ok();
    
    // Initialize logging with environment filter
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,sniper_bot=debug"));
    
    fmt()
        .with_env_filter(env_filter)
        .with_target(false)
        .with_thread_ids(true)
        .init();
    
    info!("üß† === SniperBot 2.0: The Persistent Brain === ");
    info!("üöÄ Autonomous Trading Organism - Starting...");
    
    // Parse command line arguments
    let matches = Command::new("SniperBot 2.0 - The Persistent Brain")
        .version("2.0.0-phase6")
        .author("SynergiaOS")
        .about("Autonomous AI-powered Solana trading organism with DragonflyDB brain")
        .arg(
            Arg::new("mode")
                .long("mode")
                .value_name("MODE")
                .help("Trading mode: dry-run, pilot, live")
                .default_value("dry-run")
        )
        .arg(
            Arg::new("interval")
                .long("interval")
                .value_name("SECONDS")
                .help("Processing interval in seconds")
                .default_value("300")
        )
        .arg(
            Arg::new("health-check")
                .long("health-check")
                .help("Perform health check and exit")
                .action(clap::ArgAction::SetTrue)
        )
        .get_matches();

    // Initialize global configuration
    let config = AppConfig::init();
    
    // Validate configuration
    if let Err(e) = config.validate() {
        error!("‚ùå Configuration validation failed: {}", e);
        return Err(e.into());
    }

    // Override mode if specified
    let mode = matches.get_one::<String>("mode").unwrap();
    info!("üéØ Trading mode: {}", mode);

    // Safety check for live trading
    if mode == "live" {
        warn!("‚ö†Ô∏è LIVE TRADING MODE ENABLED!");
        warn!("‚ö†Ô∏è Real money will be used for trading!");
        warn!("‚ö†Ô∏è Make sure you understand the risks!");
        
        if env::var("CONFIRM_LIVE_TRADING").unwrap_or_default() != "yes" {
            error!("‚ùå Live trading requires CONFIRM_LIVE_TRADING=yes environment variable");
            return Err("Live trading not confirmed".to_string().into());
        }
    }

    // === PHASE 2: DRAGONFLY DB CONNECTION ===
    
    info!("üêâ Connecting to DragonflyDB (The Brain)...");
    
    let db_config = DbConfig::from_env()?;
    let db_client = DbClient::new(db_config).await?;
    
    info!("‚úÖ Connected to DragonflyDB successfully");
    
    // Perform health check
    if !db_client.health_check().await? {
        error!("‚ùå DragonflyDB health check failed");
        return Err("Database health check failed".to_string().into());
    }
    
    info!("‚úÖ DragonflyDB health check passed");

    // If health check mode, exit here
    if matches.get_flag("health-check") {
        info!("üè• Health check completed successfully");
        return Ok(());
    }

    // === PHASE 3: PIPELINE CONTROLLER INITIALIZATION ===

    info!("üß† Initializing Pipeline Controller...");

    let mut pipeline_controller = PipelineController::new(db_client.clone(), config);

    // Check if pipeline is ready
    if !pipeline_controller.is_ready().await {
        error!("‚ùå Pipeline Controller is not ready");
        return Err("Pipeline not ready".to_string().into());
    }

    info!("‚úÖ Pipeline Controller initialized and ready");

    // === PHASE 4: AUTONOMOUS OPERATION LOOP ===
    
    let processing_interval = Duration::from_secs(
        matches.get_one::<String>("interval")
            .unwrap()
            .parse()
            .unwrap_or(config.main_loop.processing_interval_seconds)
    );
    
    info!("‚öôÔ∏è Processing interval: {} seconds", processing_interval.as_secs());
    info!("üîÑ Maximum opportunities per cycle: {}", config.main_loop.max_opportunities_per_cycle);
    info!("‚è±Ô∏è Cycle timeout: {} seconds", config.main_loop.cycle_timeout_seconds);
    
    let mut interval_timer = interval(processing_interval);
    let mut cycle_count = 0u64;
    
    info!("‚úÖ AUTONOMOUS ORGANISM READY - Entering continuous operation mode");
    info!("üß† The Persistent Brain is now active and processing...");
    info!("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");

    loop {
        tokio::select! {
            // Main processing cycle
            _ = interval_timer.tick() => {
                cycle_count += 1;
                
                info!("üîÑ === AUTONOMOUS CYCLE #{} STARTING ===", cycle_count);
                
                let cycle_start = std::time::Instant::now();
                
                match pipeline_controller.process_opportunities_from_db().await {
                    Ok(processed_count) => {
                        let duration = cycle_start.elapsed();
                        
                        if processed_count > 0 {
                            info!("üéâ CYCLE #{} COMPLETED: {} opportunities processed in {:.2}s", 
                                  cycle_count, processed_count, duration.as_secs_f64());
                        } else {
                            debug!("üèÅ Cycle #{} completed: No new opportunities (Duration: {:.2}s)", 
                                   cycle_count, duration.as_secs_f64());
                        }
                    }
                    Err(e) => {
                        error!("üíÄ Cycle #{} FAILED: {} (Continuing to next cycle)", cycle_count, e);
                    }
                }
                
                info!("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
            }
            
            // Graceful shutdown on SIGINT/SIGTERM
            _ = signal::ctrl_c() => {
                info!("üõë Shutdown signal received");
                break;
            }
        }
    }

    // === PHASE 5: GRACEFUL SHUTDOWN ===
    
    info!("üõë Initiating graceful shutdown...");
    
    // Perform final health check
    let health_status = pipeline_controller.health_check().await?;
    info!("üè• Final health check: {:?}", health_status);
    
    // Get final statistics
    let stats = pipeline_controller.stats();
    info!("üìä Final Statistics:");
    info!("  ‚Ä¢ Total cycles: {}", stats.cycles_completed);
    info!("  ‚Ä¢ Total candidates: {}", stats.total_candidates_found);
    info!("  ‚Ä¢ Total validated: {}", stats.total_candidates_validated);
    info!("  ‚Ä¢ Total decisions: {}", stats.total_decisions_made);
    info!("  ‚Ä¢ Average cycle time: {}ms", stats.average_cycle_duration_ms);
    
    info!("‚úÖ SniperBot 2.0 - The Persistent Brain shutdown complete");
    info!("üß† Autonomous organism has been safely deactivated");
    
    Ok(())
}
